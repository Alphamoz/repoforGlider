// Generated by gencpp from file glider_msg/imumsg.msg
// DO NOT EDIT!


#ifndef GLIDER_MSG_MESSAGE_IMUMSG_H
#define GLIDER_MSG_MESSAGE_IMUMSG_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace glider_msg
{
template <class ContainerAllocator>
struct imumsg_
{
  typedef imumsg_<ContainerAllocator> Type;

  imumsg_()
    : header()
    , gpsStatus(0)
    , latitude(0.0)
    , longitude(0.0)
    , altitude(0.0)
    , linearX(0.0)
    , linearY(0.0)
    , linearZ(0.0)
    , angularX(0.0)
    , angularY(0.0)
    , angularZ(0.0)
    , orientationX(0.0)
    , orientationY(0.0)
    , orientationZ(0.0)
    , orientationW(0.0)
    , angularVeloX(0.0)
    , angularVeloY(0.0)
    , angularVeloZ(0.0)
    , linearAccelerationX(0.0)
    , linearAccelerationY(0.0)
    , linearAccelerationZ(0.0)
    , position_covariance()
    , orientationCovariance()
    , linearAccelerationCovariance()
    , RPY()
    , systemStatusMessage()
    , statusLevel(0)  {
      position_covariance.assign(0.0);

      orientationCovariance.assign(0.0);

      linearAccelerationCovariance.assign(0.0);

      RPY.assign(0.0);
  }
  imumsg_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , gpsStatus(0)
    , latitude(0.0)
    , longitude(0.0)
    , altitude(0.0)
    , linearX(0.0)
    , linearY(0.0)
    , linearZ(0.0)
    , angularX(0.0)
    , angularY(0.0)
    , angularZ(0.0)
    , orientationX(0.0)
    , orientationY(0.0)
    , orientationZ(0.0)
    , orientationW(0.0)
    , angularVeloX(0.0)
    , angularVeloY(0.0)
    , angularVeloZ(0.0)
    , linearAccelerationX(0.0)
    , linearAccelerationY(0.0)
    , linearAccelerationZ(0.0)
    , position_covariance()
    , orientationCovariance()
    , linearAccelerationCovariance()
    , RPY()
    , systemStatusMessage(_alloc)
    , statusLevel(0)  {
  (void)_alloc;
      position_covariance.assign(0.0);

      orientationCovariance.assign(0.0);

      linearAccelerationCovariance.assign(0.0);

      RPY.assign(0.0);
  }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef int16_t _gpsStatus_type;
  _gpsStatus_type gpsStatus;

   typedef float _latitude_type;
  _latitude_type latitude;

   typedef float _longitude_type;
  _longitude_type longitude;

   typedef float _altitude_type;
  _altitude_type altitude;

   typedef float _linearX_type;
  _linearX_type linearX;

   typedef float _linearY_type;
  _linearY_type linearY;

   typedef float _linearZ_type;
  _linearZ_type linearZ;

   typedef float _angularX_type;
  _angularX_type angularX;

   typedef float _angularY_type;
  _angularY_type angularY;

   typedef float _angularZ_type;
  _angularZ_type angularZ;

   typedef float _orientationX_type;
  _orientationX_type orientationX;

   typedef float _orientationY_type;
  _orientationY_type orientationY;

   typedef float _orientationZ_type;
  _orientationZ_type orientationZ;

   typedef float _orientationW_type;
  _orientationW_type orientationW;

   typedef float _angularVeloX_type;
  _angularVeloX_type angularVeloX;

   typedef float _angularVeloY_type;
  _angularVeloY_type angularVeloY;

   typedef float _angularVeloZ_type;
  _angularVeloZ_type angularVeloZ;

   typedef float _linearAccelerationX_type;
  _linearAccelerationX_type linearAccelerationX;

   typedef float _linearAccelerationY_type;
  _linearAccelerationY_type linearAccelerationY;

   typedef float _linearAccelerationZ_type;
  _linearAccelerationZ_type linearAccelerationZ;

   typedef boost::array<double, 9>  _position_covariance_type;
  _position_covariance_type position_covariance;

   typedef boost::array<double, 9>  _orientationCovariance_type;
  _orientationCovariance_type orientationCovariance;

   typedef boost::array<double, 9>  _linearAccelerationCovariance_type;
  _linearAccelerationCovariance_type linearAccelerationCovariance;

   typedef boost::array<float, 3>  _RPY_type;
  _RPY_type RPY;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _systemStatusMessage_type;
  _systemStatusMessage_type systemStatusMessage;

   typedef int16_t _statusLevel_type;
  _statusLevel_type statusLevel;





  typedef boost::shared_ptr< ::glider_msg::imumsg_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::glider_msg::imumsg_<ContainerAllocator> const> ConstPtr;

}; // struct imumsg_

typedef ::glider_msg::imumsg_<std::allocator<void> > imumsg;

typedef boost::shared_ptr< ::glider_msg::imumsg > imumsgPtr;
typedef boost::shared_ptr< ::glider_msg::imumsg const> imumsgConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::glider_msg::imumsg_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::glider_msg::imumsg_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::glider_msg::imumsg_<ContainerAllocator1> & lhs, const ::glider_msg::imumsg_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.gpsStatus == rhs.gpsStatus &&
    lhs.latitude == rhs.latitude &&
    lhs.longitude == rhs.longitude &&
    lhs.altitude == rhs.altitude &&
    lhs.linearX == rhs.linearX &&
    lhs.linearY == rhs.linearY &&
    lhs.linearZ == rhs.linearZ &&
    lhs.angularX == rhs.angularX &&
    lhs.angularY == rhs.angularY &&
    lhs.angularZ == rhs.angularZ &&
    lhs.orientationX == rhs.orientationX &&
    lhs.orientationY == rhs.orientationY &&
    lhs.orientationZ == rhs.orientationZ &&
    lhs.orientationW == rhs.orientationW &&
    lhs.angularVeloX == rhs.angularVeloX &&
    lhs.angularVeloY == rhs.angularVeloY &&
    lhs.angularVeloZ == rhs.angularVeloZ &&
    lhs.linearAccelerationX == rhs.linearAccelerationX &&
    lhs.linearAccelerationY == rhs.linearAccelerationY &&
    lhs.linearAccelerationZ == rhs.linearAccelerationZ &&
    lhs.position_covariance == rhs.position_covariance &&
    lhs.orientationCovariance == rhs.orientationCovariance &&
    lhs.linearAccelerationCovariance == rhs.linearAccelerationCovariance &&
    lhs.RPY == rhs.RPY &&
    lhs.systemStatusMessage == rhs.systemStatusMessage &&
    lhs.statusLevel == rhs.statusLevel;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::glider_msg::imumsg_<ContainerAllocator1> & lhs, const ::glider_msg::imumsg_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace glider_msg

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::glider_msg::imumsg_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::glider_msg::imumsg_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::glider_msg::imumsg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::glider_msg::imumsg_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::glider_msg::imumsg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::glider_msg::imumsg_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::glider_msg::imumsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "d2f0d176490184beac4b63cba6827925";
  }

  static const char* value(const ::glider_msg::imumsg_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xd2f0d176490184beULL;
  static const uint64_t static_value2 = 0xac4b63cba6827925ULL;
};

template<class ContainerAllocator>
struct DataType< ::glider_msg::imumsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "glider_msg/imumsg";
  }

  static const char* value(const ::glider_msg::imumsg_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::glider_msg::imumsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header header\n"
"int16 gpsStatus\n"
"float32 latitude\n"
"float32 longitude\n"
"float32 altitude\n"
"float32 linearX\n"
"float32 linearY\n"
"float32 linearZ\n"
"float32 angularX\n"
"float32 angularY\n"
"float32 angularZ\n"
"float32 orientationX\n"
"float32 orientationY\n"
"float32 orientationZ\n"
"float32 orientationW\n"
"float32 angularVeloX\n"
"float32 angularVeloY\n"
"float32 angularVeloZ\n"
"float32 linearAccelerationX\n"
"float32 linearAccelerationY\n"
"float32 linearAccelerationZ\n"
"float64[9] position_covariance\n"
"float64[9] orientationCovariance\n"
"float64[9] linearAccelerationCovariance\n"
"float32[3] RPY\n"
"string systemStatusMessage\n"
"int16 statusLevel\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::glider_msg::imumsg_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::glider_msg::imumsg_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.gpsStatus);
      stream.next(m.latitude);
      stream.next(m.longitude);
      stream.next(m.altitude);
      stream.next(m.linearX);
      stream.next(m.linearY);
      stream.next(m.linearZ);
      stream.next(m.angularX);
      stream.next(m.angularY);
      stream.next(m.angularZ);
      stream.next(m.orientationX);
      stream.next(m.orientationY);
      stream.next(m.orientationZ);
      stream.next(m.orientationW);
      stream.next(m.angularVeloX);
      stream.next(m.angularVeloY);
      stream.next(m.angularVeloZ);
      stream.next(m.linearAccelerationX);
      stream.next(m.linearAccelerationY);
      stream.next(m.linearAccelerationZ);
      stream.next(m.position_covariance);
      stream.next(m.orientationCovariance);
      stream.next(m.linearAccelerationCovariance);
      stream.next(m.RPY);
      stream.next(m.systemStatusMessage);
      stream.next(m.statusLevel);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct imumsg_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::glider_msg::imumsg_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::glider_msg::imumsg_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "gpsStatus: ";
    Printer<int16_t>::stream(s, indent + "  ", v.gpsStatus);
    s << indent << "latitude: ";
    Printer<float>::stream(s, indent + "  ", v.latitude);
    s << indent << "longitude: ";
    Printer<float>::stream(s, indent + "  ", v.longitude);
    s << indent << "altitude: ";
    Printer<float>::stream(s, indent + "  ", v.altitude);
    s << indent << "linearX: ";
    Printer<float>::stream(s, indent + "  ", v.linearX);
    s << indent << "linearY: ";
    Printer<float>::stream(s, indent + "  ", v.linearY);
    s << indent << "linearZ: ";
    Printer<float>::stream(s, indent + "  ", v.linearZ);
    s << indent << "angularX: ";
    Printer<float>::stream(s, indent + "  ", v.angularX);
    s << indent << "angularY: ";
    Printer<float>::stream(s, indent + "  ", v.angularY);
    s << indent << "angularZ: ";
    Printer<float>::stream(s, indent + "  ", v.angularZ);
    s << indent << "orientationX: ";
    Printer<float>::stream(s, indent + "  ", v.orientationX);
    s << indent << "orientationY: ";
    Printer<float>::stream(s, indent + "  ", v.orientationY);
    s << indent << "orientationZ: ";
    Printer<float>::stream(s, indent + "  ", v.orientationZ);
    s << indent << "orientationW: ";
    Printer<float>::stream(s, indent + "  ", v.orientationW);
    s << indent << "angularVeloX: ";
    Printer<float>::stream(s, indent + "  ", v.angularVeloX);
    s << indent << "angularVeloY: ";
    Printer<float>::stream(s, indent + "  ", v.angularVeloY);
    s << indent << "angularVeloZ: ";
    Printer<float>::stream(s, indent + "  ", v.angularVeloZ);
    s << indent << "linearAccelerationX: ";
    Printer<float>::stream(s, indent + "  ", v.linearAccelerationX);
    s << indent << "linearAccelerationY: ";
    Printer<float>::stream(s, indent + "  ", v.linearAccelerationY);
    s << indent << "linearAccelerationZ: ";
    Printer<float>::stream(s, indent + "  ", v.linearAccelerationZ);
    s << indent << "position_covariance[]" << std::endl;
    for (size_t i = 0; i < v.position_covariance.size(); ++i)
    {
      s << indent << "  position_covariance[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.position_covariance[i]);
    }
    s << indent << "orientationCovariance[]" << std::endl;
    for (size_t i = 0; i < v.orientationCovariance.size(); ++i)
    {
      s << indent << "  orientationCovariance[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.orientationCovariance[i]);
    }
    s << indent << "linearAccelerationCovariance[]" << std::endl;
    for (size_t i = 0; i < v.linearAccelerationCovariance.size(); ++i)
    {
      s << indent << "  linearAccelerationCovariance[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.linearAccelerationCovariance[i]);
    }
    s << indent << "RPY[]" << std::endl;
    for (size_t i = 0; i < v.RPY.size(); ++i)
    {
      s << indent << "  RPY[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.RPY[i]);
    }
    s << indent << "systemStatusMessage: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.systemStatusMessage);
    s << indent << "statusLevel: ";
    Printer<int16_t>::stream(s, indent + "  ", v.statusLevel);
  }
};

} // namespace message_operations
} // namespace ros

#endif // GLIDER_MSG_MESSAGE_IMUMSG_H
